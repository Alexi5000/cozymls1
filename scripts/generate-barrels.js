#!/usr/bin/env node

import { existsSync, mkdirSync, writeFileSync, readFileSync, readdirSync, statSync } from 'fs';
import { resolve, dirname, join, relative, extname, basename } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const ROOT_DIR = resolve(__dirname, '..');
const SRC_DIR = join(ROOT_DIR, 'src');

// FSD layers in order of dependency (lower layers can't depend on higher layers)
const FSD_LAYERS = [
  'shared',
  'entities', 
  'features',
  'widgets',
  'processes',
  'pages',
  'app'
];

// File extensions to include in barrel exports
const EXPORT_EXTENSIONS = ['.ts', '.tsx', '.js', '.jsx'];

// Files to exclude from barrel exports
const EXCLUDE_FILES = [
  'index.ts',
  'index.tsx', 
  'index.js',
  'index.jsx',
  '.test.',
  '.spec.',
  '.stories.',
  '.d.ts'
];

// Directories to exclude from barrel exports
const EXCLUDE_DIRECTORIES = [
  '__tests__',
  'test',
  'tests',
  'spec',
  'specs',
  'stories',
  'node_modules',
  '.git',
  'dist',
  'build'
];

/**
 * Check if a file should be included in barrel exports
 */
function shouldIncludeFile(fileName) {
  // Check extension
  const hasValidExtension = EXPORT_EXTENSIONS.some(ext => fileName.endsWith(ext));
  if (!hasValidExtension) return false;
  
  // Check exclusions
  const isExcluded = EXCLUDE_FILES.some(pattern => fileName.includes(pattern));
  return !isExcluded;
}

/**
 * Get all exportable files in a directory
 */
function getExportableFiles(dirPath) {
  if (!existsSync(dirPath)) return [];
  
  const files = [];
  const items = readdirSync(dirPath);
  
  for (const item of items) {
    const itemPath = join(dirPath, item);
    const stat = statSync(itemPath);
    
    if (stat.isFile() && shouldIncludeFile(item)) {
      files.push(item);
    } else if (stat.isDirectory()) {
      // Check if directory should be excluded
      const isExcludedDir = EXCLUDE_DIRECTORIES.includes(item);
      if (isExcludedDir) continue;
      
      // Check if directory has an index file
      const indexFiles = ['index.ts', 'index.tsx', 'index.js', 'index.jsx'];
      const hasIndex = indexFiles.some(indexFile => existsSync(join(itemPath, indexFile)));
      
      if (hasIndex) {
        files.push(item);
      }
    }
  }
  
  return files;
}

/**
 * Generate export statement for a file or directory
 */
function generateExportStatement(item) {
  const itemName = basename(item, extname(item));
  const isDirectory = !extname(item);
  
  if (isDirectory) {
    // Export everything from directory index
    return `export * from './${item}';`;
  } else {
    // Export everything from file
    const pathWithoutExt = item.replace(extname(item), '');
    return `export * from './${pathWithoutExt}';`;
  }
}

/**
 * Generate barrel index.ts file content
 */
function generateBarrelContent(dirPath) {
  const files = getExportableFiles(dirPath);
  
  if (files.length === 0) {
    return '// No exports available in this directory\n';
  }
  
  const exports = files
    .sort()
    .map(generateExportStatement)
    .join('\n');
  
  return `// Auto-generated barrel file
// This file is automatically generated by scripts/generate-barrels.js
// Do not edit manually - your changes will be overwritten

${exports}
`;
}

/**
 * Generate barrel file for a specific directory
 */
function generateBarrelFile(dirPath) {
  const indexPath = join(dirPath, 'index.ts');
  const content = generateBarrelContent(dirPath);
  
  // Only write if content has changed
  let shouldWrite = true;
  if (existsSync(indexPath)) {
    const existingContent = readFileSync(indexPath, 'utf8');
    shouldWrite = existingContent !== content;
  }
  
  if (shouldWrite) {
    writeFileSync(indexPath, content);
    console.log(`‚úì Generated barrel: ${relative(ROOT_DIR, indexPath)}`);
  } else {
    console.log(`- Unchanged: ${relative(ROOT_DIR, indexPath)}`);
  }
}

/**
 * Recursively generate barrel files for a directory and its subdirectories
 */
function generateBarrelsRecursively(dirPath, maxDepth = 3, currentDepth = 0) {
  if (currentDepth > maxDepth || !existsSync(dirPath)) {
    return;
  }
  
  // Generate barrel for current directory
  generateBarrelFile(dirPath);
  
  // Process subdirectories
  const items = readdirSync(dirPath);
  for (const item of items) {
    const itemPath = join(dirPath, item);
    const stat = statSync(itemPath);
    
    if (stat.isDirectory() && !item.startsWith('.') && !EXCLUDE_DIRECTORIES.includes(item)) {
      generateBarrelsRecursively(itemPath, maxDepth, currentDepth + 1);
    }
  }
}

/**
 * Main function to generate all barrel files
 */
function generateAllBarrels() {
  console.log('üöÄ Generating barrel files for FSD layers...\n');
  
  for (const layer of FSD_LAYERS) {
    const layerPath = join(SRC_DIR, layer);
    
    if (existsSync(layerPath)) {
      console.log(`üìÅ Processing layer: ${layer}`);
      generateBarrelsRecursively(layerPath);
      console.log('');
    } else {
      console.log(`‚ö†Ô∏è  Layer directory not found: ${layer}`);
    }
  }
  
  console.log('‚úÖ Barrel generation complete!');
}

/**
 * Watch mode - regenerate barrels when files change
 */
function watchMode() {
  console.log('üëÄ Watching for file changes...');
  
  // Simple polling-based watch (for cross-platform compatibility)
  const watchInterval = 2000; // 2 seconds
  const watchedPaths = new Map();
  
  function scanDirectory(dirPath) {
    const files = new Map();
    
    function scan(currentPath) {
      if (!existsSync(currentPath)) return;
      
      const items = readdirSync(currentPath);
      for (const item of items) {
        const itemPath = join(currentPath, item);
        const stat = statSync(itemPath);
        
        if (stat.isFile()) {
          files.set(itemPath, stat.mtime.getTime());
        } else if (stat.isDirectory() && !item.startsWith('.')) {
          scan(itemPath);
        }
      }
    }
    
    scan(dirPath);
    return files;
  }
  
  function checkForChanges() {
    let hasChanges = false;
    
    for (const layer of FSD_LAYERS) {
      const layerPath = join(SRC_DIR, layer);
      if (!existsSync(layerPath)) continue;
      
      const currentFiles = scanDirectory(layerPath);
      const previousFiles = watchedPaths.get(layer) || new Map();
      
      // Check for changes
      if (currentFiles.size !== previousFiles.size) {
        hasChanges = true;
      } else {
        for (const [filePath, mtime] of currentFiles) {
          if (previousFiles.get(filePath) !== mtime) {
            hasChanges = true;
            break;
          }
        }
      }
      
      watchedPaths.set(layer, currentFiles);
    }
    
    if (hasChanges) {
      console.log('\nüìù Files changed, regenerating barrels...');
      generateAllBarrels();
    }
  }
  
  // Initial scan
  generateAllBarrels();
  
  // Start watching
  setInterval(checkForChanges, watchInterval);
}

// CLI interface
const args = process.argv.slice(2);
const command = args[0];

switch (command) {
  case 'watch':
    watchMode();
    break;
  case 'help':
    console.log(`
FSD Barrel Generator

Usage:
  node scripts/generate-barrels.js [command]

Commands:
  (none)  Generate all barrel files once
  watch   Watch for file changes and regenerate barrels
  help    Show this help message

Examples:
  npm run generate-barrels
  npm run generate-barrels watch
`);
    break;
  default:
    generateAllBarrels();
}
